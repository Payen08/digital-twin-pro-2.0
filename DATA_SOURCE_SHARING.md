# 数据源共享机制说明

## 🎯 核心概念

### 数据源 vs 场景

**数据源 (Data Source)**
- 物理世界的"绝对真理"
- 公共资源池
- 包含：SLAM 地图 + 路网拓扑
- **只读共享**，不被任何场景独占

**场景 (Scene)**
- 基于某个数据源创建的"实例"或"副本"
- 每个场景有独立的配置空间
- 可以自由定制点位模型、装饰物等
- 多个场景可以引用同一个数据源

---

## 📊 关系图解

```
┌─────────────────────────────────────────┐
│   基础数据源 (SLAM地图 + 路网API)      │
│   - 1.5 场景地图                        │
│   - 2楼地图                             │
│   - 3楼地图                             │
└─────────────────────────────────────────┘
          ↓ 只读引用 (Reference)
    ┌─────┴─────┬─────────┬─────────┐
    ↓           ↓         ↓         ↓
┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐
│场景 1  │ │场景 2  │ │场景 3  │ │场景 4  │
│监控视图│ │规划视图│ │历史回放│ │AB测试 │
└────────┘ └────────┘ └────────┘ └────────┘
    ↓           ↓         ↓         ↓
 Scene1.json Scene2.json Scene3.json Scene4.json
 (配置A)     (配置B)     (配置C)     (配置D)
```

---

## 🔑 为什么不冲突？

### 1. 引用而非占用 (Reference, not Lock)

```javascript
// 场景 1 创建时
const scene1 = {
    id: 'scene_001',
    name: '场景 1',
    baseMapId: 'map_1_5',  // 只是记录引用
    mapPath: './1.5_地图.json'
};

// 场景 2 创建时
const scene2 = {
    id: 'scene_002',
    name: '场景 2',
    baseMapId: 'map_1_5',  // 同样引用
    mapPath: './1.5_地图.json'
};

// 两个场景都只是读取同一个 ID 的数据来渲染底图
// 并没有"独占"这个文件
```

### 2. 独立的配置空间 (Independent Scope)

```javascript
// 场景 1 的配置
{
    "sceneId": "scene_001",
    "entities": [
        {
            "sourceRefId": "1001",  // 绑定路网点位 1001
            "visualConfig": {
                "modelUrl": "/models/red_forklift.glb",
                "color": "#FF0000"
            }
        }
    ]
}

// 场景 2 的配置
{
    "sceneId": "scene_002",
    "entities": [
        {
            "sourceRefId": "1001",  // 同样绑定路网点位 1001
            "visualConfig": {
                "modelUrl": null,  // 使用默认方块
                "color": "#0000FF"
            }
        }
    ]
}

// 同一个点位，在不同场景中有不同的视觉表现
// 配置保存在各自的 Scene.json 中，互不干扰
```

### 3. 物理层隔离

```
路网数据源 (只读)
    ↓
场景快照 (内存副本)
    ↓
用户编辑 (仅作用于快照)
    ↓
保存配置 (Scene.json)

✅ 无论你在场景 2 里怎么拖动墙体、修改装饰
✅ 都不会反向修改到底层的"数据源"
✅ 也不会影响场景 1 的配置
```

---

## 💡 业务应用场景

### 场景 1: 多楼层管理

```
场景 1 → 绑定"一楼数据源"
场景 2 → 绑定"二楼数据源"
场景 3 → 绑定"三楼数据源"

✅ 它们互不干扰，但在同一个项目中管理
✅ 可以快速切换查看不同楼层
```

### 场景 2: AB Test / 方案对比

```
场景 1（当前方案）
├─ 绑定"车间路网"
├─ 按现状摆放设备
└─ 用于日常监控

场景 2（未来方案）
├─ 绑定同一个"车间路网"
├─ 重新规划虚拟墙体
├─ 增加虚拟货架
└─ 用于演示"如果这样改造会怎么样"

✅ 可以同时保留两个方案
✅ 不影响机器人的实际运行
✅ 方便对比和决策
```

### 场景 3: 历史回放

```
场景 1（实时监控）
├─ 绑定"车间路网"
└─ 显示当前设备状态

场景 2（历史回放）
├─ 绑定同一个"车间路网"
├─ 加载历史数据
└─ 回放昨天的运行轨迹

✅ 同一个地图，不同的数据源
✅ 互不干扰
```

---

## 🔧 技术实现

### 场景创建流程

```javascript
// 1. 拉取数据源列表
const availableMaps = getAvailableMaps();

// 2. 用户选择数据源
const selectedMapPath = './1.5_地图.json';

// 3. 加载数据源（只读）
const { baseMap, entities, paths } = await parseFullMapJson(selectedMapPath);

// 4. 创建场景快照（内存副本）
const newScene = {
    id: uuidv4(),
    name: '场景 1',
    mapPath: selectedMapPath,  // 记录引用
    objects: [
        baseMap,      // 底图快照
        ...entities,  // 点位快照
        ...paths      // 路径快照
    ]
};

// 5. 用户编辑（仅作用于快照）
// 修改点位颜色、添加装饰物等
// 不影响原始数据源

// 6. 保存配置
saveSceneConfig(newScene);
```

### 数据源缓存机制

```javascript
const [floorDataCache, setFloorDataCache] = useState({});

// 首次加载数据源
const loadDataSource = async (mapPath) => {
    // 检查缓存
    if (floorDataCache[mapPath]) {
        console.log('✅ 从缓存加载');
        return floorDataCache[mapPath];
    }
    
    // 加载数据源
    const data = await fetch(mapPath).then(r => r.json());
    const parsed = parseFullMapJson(data);
    
    // 缓存数据源
    setFloorDataCache(prev => ({
        ...prev,
        [mapPath]: parsed
    }));
    
    return parsed;
};

// 多个场景使用同一数据源时，只加载一次
```

---

## 📋 UI 设计

### 场景管理对话框

```
┌─────────────────────────────────────────┐
│ 场景管理                           ✕   │
├─────────────────────────────────────────┤
│                                         │
│  [+ 新增场景]                           │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │ 场景 1                    ✏️ 🗑️ │   │
│  │ 包含 15 个点位                  │   │
│  │ 数据源: 1.5 场景地图            │   │
│  └─────────────────────────────────┘   │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │ 场景 2                    ✏️ 🗑️ │   │
│  │ 包含 15 个点位                  │   │
│  │ 数据源: 1.5 场景地图 (共享)    │   │
│  └─────────────────────────────────┘   │
│                                         │
└─────────────────────────────────────────┘
```

### 编辑场景对话框

```
┌─────────────────────────────────────────┐
│ 编辑场景                           ✕   │
├─────────────────────────────────────────┤
│                                         │
│  * 场景名称                             │
│  [场景 2                          ]     │
│                                         │
│  * 场景基础数据源                       │
│  （只读共享，多场景可使用同一数据源）   │
│  [1.5 场景地图 ▼]  [🔄 更新路网]       │
│                                         │
│  * 底图选择                             │
│  [标准建筑底图 ▼]                       │
│                                         │
└─────────────────────────────────────────┘
```

---

## ✅ 关键特性

### 1. 只读共享 ✅
- 数据源不被任何场景独占
- 多个场景可以同时引用同一数据源
- 不会产生冲突

### 2. 独立配置 ✅
- 每个场景有独立的配置空间
- 修改场景 1 不影响场景 2
- 配置保存在各自的 Scene.json 中

### 3. 高效缓存 ✅
- 数据源只加载一次
- 多个场景共享缓存
- 提高性能

### 4. 灵活切换 ✅
- 可以快速在不同场景间切换
- 每个场景保持独立状态
- 不会丢失配置

---

## 🎯 总结

**场景创建时的逻辑**:

1. **拉取**: 从公共库中拉取数据源列表
2. **实例化**: 选中数据源后，在内存中生成一份该数据源的"孪生快照"
3. **独立**: 此后该场景的所有操作，仅作用于这份"快照"
4. **隔离**: 与引用了同一数据源的其他场景完全隔离

**核心优势**:

- ✅ 数据源只读共享，不冲突
- ✅ 场景配置独立，不干扰
- ✅ 支持多场景管理
- ✅ 支持 AB 测试和方案对比
- ✅ 高效的缓存机制

---

**版本**: 1.0.0  
**最后更新**: 2025-11-24  
**实现状态**: ✅ 完成
